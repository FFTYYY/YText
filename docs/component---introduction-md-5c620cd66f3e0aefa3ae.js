(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{DIrE:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return h}));var a=n("Fcif"),o=n("+I+c"),r=(n("mXGw"),n("/FXl")),i=n("TjRS"),s=(n("aD51"),["components"]),c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!Object.prototype.hasOwnProperty.call(c,"__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"introduction.md"}});var l={_frontmatter:c},p=i.a;function h(e){var t=e.components,n=Object(o.a)(e,s);return Object(r.b)(p,Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"introduction"},"Introduction"),Object(r.b)("p",null,"I believe articles are not barely texts, nor visual elements.\nAlthough our language is linear, words come one after another, we humen's mind is far from linear,\nstructures, branching, moods exist therein.\nTherefore I build ",Object(r.b)("strong",{parentName:"p"},"YText"),", a text editor library that decouples the abstract structure and concrete visualization of an article."),Object(r.b)("p",null,"YText is composed of three major components:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Editor, which allows one to edit the structure of an article without specifying how to render it."),Object(r.b)("li",{parentName:"ul"},"Printer, which allows one to define how to render the abatract representation of an article (say into a web page)."),Object(r.b)("li",{parentName:"ul"},"Concept System, which is shared by editor and printer, defining how to represent an article by the abstract representation.")),Object(r.b)("p",null,'The so called "abstract representation"\n(terminology wise I call it  ',Object(r.b)("strong",{parentName:"p"},"intermediate representation"),', since the word "abstract" is used in another situation)\nof an article is organized as a tree\n(a json tree in implementation), whose nodes are concepts or trivial nodes. '),Object(r.b)("h2",{id:"about-realization"},'About "Realization"'),Object(r.b)("p",null,'Sometimes I use the word "realization", it is analogous to the term with the same name in OOP programing.\nIn YText, some times an element provides a name and a group of ',Object(r.b)("em",{parentName:"p"},"parameter prototype"),",\nand another element specify a name and ",Object(r.b)("em",{parentName:"p"},"values of paramater"),", which is of the same type with the coresponding parameter prototype.\nIn this case, I say the latter elements realizes the former element. "),Object(r.b)("p",null,"Notice that in YText, element names (or together with some other properties, like class), serves as the unique indicator of an element,\nwhich is like class name in OOP. The parameter prototype does not only defines how a parameter would be,\nbut also serves as the default value of the parameters which can be used when coresponding term is not specified and can be overrided."),Object(r.b)("h1",{id:"the-grammar-of-intermediate-representation"},"The Grammar of Intermediate Representation"),Object(r.b)("p",null,"As mentioned before, the intermediate representation in YText is a tree. Therefore two types of non-leaf nodes in this tree: "),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Concept nodes, and"),Object(r.b)("li",{parentName:"ol"},"Paragraph nodes,")),Object(r.b)("p",null,"and leaf nodes are all called text nodes. A text node is basically a string, which corresponding to a phrase in the article.\nA paragraph node is a list of text nodes and inline concept nodes (will explain later), which corresponding to a paragraph in the article."),Object(r.b)("h2",{id:"concept--concept-nodes"},"Concept & Concept nodes"),Object(r.b)("p",null,"Each concept node belongs to a concept, which is specified by user, and it also provodes a group of parameters which ",Object(r.b)("em",{parentName:"p"},"realizes")," the concept.\nEach ",Object(r.b)("strong",{parentName:"p"},"concept")," should specifies four properties:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},'The concept type, which is in {"group", "structure", "inline", "support", "abstract"}, which defines which kind of concept the concept is.'),Object(r.b)("li",{parentName:"ol"},"The parameter prototype of this concept."),Object(r.b)("li",{parentName:"ol"},"The values of meta parameters. Meta -parameters are specified by YText."),Object(r.b)("li",{parentName:"ol"},"The values of inherent parameters. Inherent are specified by YText."),Object(r.b)("li",{parentName:"ol"},"The rendering method which takes concept parameter realization as input and defines how to render this concept into a visual element.")),Object(r.b)("h3",{id:"concept-types"},"Concept Types"),Object(r.b)("p",null,"Concept types are pre-defined in YText. There are five concept types: group, structure, inline, support and abstract.\nEach concept type defines specifies a group of parameter prototype, which is called the inherent parameters of this concept type.\nEach concept type also defines a local grammar, namely what type of nodes can its children be.\nThe detailed definition of each type will be discussed later, but here I breifly explain each type, to give you a intuiation about each type."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"A ",Object(r.b)("strong",{parentName:"li"},"group")," node is a list of paragrahs, which is it self be seen as a whole.\nFor examples a theorem in a mathmatics paper can be viewed as a group node. The ",Object(r.b)("inlineCode",{parentName:"li"},"\\item")," element in LateX can also be viewed as a group.\nGroup nodes can form series, in which the group nodes comes one after the other (I call this ",Object(r.b)("strong",{parentName:"li"},"chaining"),"),\nfor example the ",Object(r.b)("inlineCode",{parentName:"li"},"enumerate")," environment in LateX.\nA proof comes right after a theorem in a mathmatics paper is also an example of chaining group nodes."),Object(r.b)("li",{parentName:"ol"},"A ",Object(r.b)("strong",{parentName:"li"},"structure")," node consists of several Group nodes.\nA structure node should be rendered in a a different direction of the ordinary direction of the document.\nIf the document is rendered from top to bottom, then a structure node renders from left to right. One line in a table is an example."),Object(r.b)("li",{parentName:"ol"},"An ",Object(r.b)("strong",{parentName:"li"},"inline")," node is of the same position of text nodes, but with styles. The ",Object(r.b)("inlineCode",{parentName:"li"},"<strong>")," tag in HTML is an example."),Object(r.b)("li",{parentName:"ol"},"A ",Object(r.b)("strong",{parentName:"li"},"support")," node is a visual element that does not contain text contents\n(or more generally, can only contain an empty text node as its child).\nSupport nodes are the non-text visual elements in an article. For example figures, images, table lines.\nIt can even be non-visualable to printer and just serve as an aid to editor. "),Object(r.b)("li",{parentName:"ol"},"An ",Object(r.b)("strong",{parentName:"li"},"abstract"),' node is simply the root node of a tree.\nThe word "abstract" comes from a machanism in YText which allows an article fissions into several in the middle,\nwhich we will dicuss detailly later.')),Object(r.b)("h3",{id:"meta-parameters"},"Meta Parameters"),Object(r.b)("p",null,"YText specified meta parameter prototype, which should be realized by every concept node. There are three values to be specified:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"force-block: If we force an element (mainly inline or support) to be rendered as a block in HTML."),Object(r.b)("li",{parentName:"ol"},"force-inline: If we force an element (mainly group, structure or support) to be rendered as an inline element in HTML."),Object(r.b)("li",{parentName:"ol"},"force-void: If we force an element to be uneditable (which is like support nodes).")),Object(r.b)("h3",{id:"first-class-concepts-and-second-class-concepts"},"First Class Concepts and Second Class Concepts"),Object(r.b)("p",null,"As wise readers might have noticed, each concept node have two types of properties:\nthose for defining intermediate trees and those for specifying how a node to rendered.\nTheoretically this might not be a problem, but technically, if a user of YText might not be the user of the editor:\nUser A might use YText to develop a library, providing an implementation of the printer and editor,\nand provided it to user B who defines concepts and use them to write articles. Here problems occurs:\nwhen a library author leave users the freedom of defining their own concepts,\nthey don't mean to let users write js code to define how to render the concept nodes.\nTherefore, the rendering part and the structure defining part of a concept must be splitted.\nTo this end, each concept in YText is composed of two parts, I call them first class concepts and second class concepts."),Object(r.b)("p",null,"A first class concept, which should be provided by the library developer,\nspecifies the concept type, a parameter prototype and the render function.\nA second class concept, which should be provided by the terminal user,\nspecifies a first class concept and another parameter prototype\nand the ",Object(r.b)("em",{parentName:"p"},"rule to convert second class parameters into first class parameters"),"."),Object(r.b)("p",null,'Generally speaking, a first class concept should be universal enough which has several "slots" and agnostic to second class concepts.\nThe second class concept fill in those slots by inidcating first class parameters.'),Object(r.b)("h2",{id:"abstract"},"Abstract"),Object(r.b)("p",null,'Each concept node has another property "abstract", which is a list of abstract nodes (can be empty).\nAs mentioned before, abstract nodes are roots of an intermediate tree.\nTherefore, the "abstract" property allows us to write a new article which ties at the current node.'),Object(r.b)("p",null,"The use of abstract can be quite flexible. For example, it can be used to write footnotes and sidenotes\n(the way of rendering it is up to our implementation).\nIt can also be used to fold too long or not important contents, like the proof of a theorem in a mathmatics paper,\na supplementary figure, or a comment that breaks the coherency wherever it is placed in the main text."),Object(r.b)("p",null,"Notice that absract defines a new article, that has no difference with the original one, which means it can be as complecated,\nand the elements therein can also have abstracts. This mechanism allows a quite complex structure of an article, like a net.\nThe structure of an article needs no longer to be linear. An article can be fissioned at the half and each goes to a complete article."),Object(r.b)("h2",{id:"implementation"},"Implementation"),Object(r.b)("p",null,"To use YText, a user need to specify three components: the implementation of editor, the implementation of printer,\nand the definition of concepts. However, a user might not want to write an editor from their own.\nTo this end, YText provides a default implementation of editor and printer,\nfor those who don't care about the implementation of editors and printers."),Object(r.b)("p",null,"The decomposing of editor, printer and concepts also means every component can be used in a plugin manner.\nA user can use the editor of imeplementation A of YText, and use printer of imeplementation B of YText,\nand define their own concepts.\nThey can even combine different imeplementations,\nlike using just a small component of imeplementation A and other parts of imeplementation B. "))}void 0!==h&&h&&h===Object(h)&&Object.isExtensible(h)&&!Object.prototype.hasOwnProperty.call(h,"__filemeta")&&Object.defineProperty(h,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"introduction.md"}}),h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---introduction-md-5c620cd66f3e0aefa3ae.js.map