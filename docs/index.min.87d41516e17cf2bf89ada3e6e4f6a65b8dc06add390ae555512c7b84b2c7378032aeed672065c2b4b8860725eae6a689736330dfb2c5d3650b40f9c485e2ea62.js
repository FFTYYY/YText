var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/YText/docs/notes-in-chinese/intro/",title:"Introduction",description:`以下是我开发的时候写的一些笔记。没有写的很严谨，不完全符合现在的版本，仅供参考。
YText是一个文档编辑库，其核心包括两个部分：
编辑器（Editor）：将用所见即所得的方式来编辑文档的中间表示； 印刷器（Printer）：将文档的中间表示渲染成网页。 其中，『文档的中间表示（ intermediate-representation ）』是YText表示文档的真正方式。其将文档组织成树，只保留语义信息，不包含样式或者排版信息。
中间表示的语法 #一个文档的中间表示将文档组织成树，树上的非叶子节点有两种类型：
段落节点（paragraph）； 概念节点（concept）， 而叶节点一定是文本节点（text）。其中，概念节点有四种类型：
组（Group）； 结构（Structure）； 支撑（Support）； 行内（Inline）， 另外，节点本身可以包含若干新的树作为其属性（不是子树），这一类树的根节点本质上也是组，但是为了区分，称其为抽象（Abstract）节点。
一棵树的根节点一定是抽象节点，叶节点一定是文本节点。
任何一个概念节点有三种参数：
参数（Parameters）：由概念定义，且在编辑过程中可以更改的参数； 元参数（meta-parameters）：由概念定义，且在编辑过程中不可更改的参数； 固有参数（inherent-parameters）：由概念类型定义，且在编辑过程中可以更改的参数。 概念 #在YText中，有一种被称为『概念』的概念。大体上来说，概念对应于文档中的可辨认的一个部分（例如定理）。 一个概念的定义要包含以下几个部分：
对应的特殊节点类型，以及对应的元参数（meta-parameters）取值； 参数（parameters）列表原型，包括参数的默认值； 这个节点的渲染方式， 可见，从概念开始，就需要定义如何渲染的问题了。
一级概念和二级概念 #一级概念（first-concept）和二级概念（second-concept）是为了向实践妥协而区分出的概念。大体来说，我们一方面希望概念由文档自身定义，另一方面因为概念包含渲染等问题，我们不可能在文档里包含一段js程序用于描述渲染（更不用提定义如何渲染本身就是一个大工程），因此我们对概念分级。大体来说，一级概念是在安装时确定的，其所有实现都是在代码里硬编码的。而二级概念则将一个一级概念作为其属性，并定义如何重写（override）一级概念的参数列表。重写有两种方式：
固定（Fix）：固定某个原先参数的值，使之不可改变； 改变默认值（Change-Default）：改变某个原先参数的默认值，注意这一步中可以新增参数； 中间表示实现 #接下来简述中间表示的具体实现。中间表示表示成一个json树。其中每个叶节点一定是一个文本节点。
interface TextNode {text: string}表示一段文本。
而一个段落节点只能包含文本（text）节点和行内（inline）节点。
interface ParagraphNode {type: \u0026quot;paragraph\u0026quot;children: (Text | Inline) []}对于概念，之前说过，其需要有固有参数和元参数，元参数包括三个值：
是否强制这个节点为行内（Inline）节点； 是否强制这个节点为空（Void）节点； 是否强制这个节点为块级（Block）节点： interface MetaParameters{forceInline?: boolean,forceBlock?: boolean,forceVoid?: boolean,}注意，元参数通常是用来对支撑节点进行补充说明的，因为支撑节点本身并不明确应该作为块级、行内还是空元素。其他特殊类型的节点，其类型本身给予了此类清晰，例如行内节点应该作为行内元素，组节点应该作为块级元素。但是对于其他特殊类型，也保留确定元参数的自由。`,content:`以下是我开发的时候写的一些笔记。没有写的很严谨，不完全符合现在的版本，仅供参考。
YText是一个文档编辑库，其核心包括两个部分：
编辑器（Editor）：将用所见即所得的方式来编辑文档的中间表示； 印刷器（Printer）：将文档的中间表示渲染成网页。 其中，『文档的中间表示（ intermediate-representation ）』是YText表示文档的真正方式。其将文档组织成树，只保留语义信息，不包含样式或者排版信息。
中间表示的语法 #一个文档的中间表示将文档组织成树，树上的非叶子节点有两种类型：
段落节点（paragraph）； 概念节点（concept）， 而叶节点一定是文本节点（text）。其中，概念节点有四种类型：
组（Group）； 结构（Structure）； 支撑（Support）； 行内（Inline）， 另外，节点本身可以包含若干新的树作为其属性（不是子树），这一类树的根节点本质上也是组，但是为了区分，称其为抽象（Abstract）节点。
一棵树的根节点一定是抽象节点，叶节点一定是文本节点。
任何一个概念节点有三种参数：
参数（Parameters）：由概念定义，且在编辑过程中可以更改的参数； 元参数（meta-parameters）：由概念定义，且在编辑过程中不可更改的参数； 固有参数（inherent-parameters）：由概念类型定义，且在编辑过程中可以更改的参数。 概念 #在YText中，有一种被称为『概念』的概念。大体上来说，概念对应于文档中的可辨认的一个部分（例如定理）。 一个概念的定义要包含以下几个部分：
对应的特殊节点类型，以及对应的元参数（meta-parameters）取值； 参数（parameters）列表原型，包括参数的默认值； 这个节点的渲染方式， 可见，从概念开始，就需要定义如何渲染的问题了。
一级概念和二级概念 #一级概念（first-concept）和二级概念（second-concept）是为了向实践妥协而区分出的概念。大体来说，我们一方面希望概念由文档自身定义，另一方面因为概念包含渲染等问题，我们不可能在文档里包含一段js程序用于描述渲染（更不用提定义如何渲染本身就是一个大工程），因此我们对概念分级。大体来说，一级概念是在安装时确定的，其所有实现都是在代码里硬编码的。而二级概念则将一个一级概念作为其属性，并定义如何重写（override）一级概念的参数列表。重写有两种方式：
固定（Fix）：固定某个原先参数的值，使之不可改变； 改变默认值（Change-Default）：改变某个原先参数的默认值，注意这一步中可以新增参数； 中间表示实现 #接下来简述中间表示的具体实现。中间表示表示成一个json树。其中每个叶节点一定是一个文本节点。
interface TextNode {text: string}表示一段文本。
而一个段落节点只能包含文本（text）节点和行内（inline）节点。
interface ParagraphNode {type: \u0026quot;paragraph\u0026quot;children: (Text | Inline) []}对于概念，之前说过，其需要有固有参数和元参数，元参数包括三个值：
是否强制这个节点为行内（Inline）节点； 是否强制这个节点为空（Void）节点； 是否强制这个节点为块级（Block）节点： interface MetaParameters{forceInline?: boolean,forceBlock?: boolean,forceVoid?: boolean,}注意，元参数通常是用来对支撑节点进行补充说明的，因为支撑节点本身并不明确应该作为块级、行内还是空元素。其他特殊类型的节点，其类型本身给予了此类清晰，例如行内节点应该作为行内元素，组节点应该作为块级元素。但是对于其他特殊类型，也保留确定元参数的自由。
而概念的固有参数则和概念类型有关。在接下来的分类型实现中详述。
关于参数原型 #注意，节点的参数是要参与编辑的，因此其不能是任意对象，只能是可以是基本类型，也就是字符串（string）、数字（number）和布尔值（boolean），但是对于fixed的参数，还可以是一个简单函数，用来表示这个参数的值由其他参数的值间接确定。
type ParameterValue = {type: \u0026quot;string\u0026quot; , val: string} |{type: \u0026quot;number\u0026quot; , val: number} | {type: \u0026quot;boolean\u0026quot; , val: boolean}type FixedParameterValue = ParameterValue | {\u0026quot;type\u0026quot;: \u0026quot;function\u0026quot; , val: string}interface ParameterList{[key: string]: ParameterValue}interface FixedParameterList{[key: string]: FixedParameterValue}对于类型是函数的参数，其值应该是一个类似于这样的字符串：
\u0026quot;p=\u0026gt;p.x.val\u0026quot;在解释时，会将整个节点的当前参数列表作为p传入。
缓存结果 #除此之外，每个概念节点还可以有一个属性缓存结果（Result Cache），用来保存印刷中保存的中间结果，以便需要引用时不必重新完成整个印刷流程。
缓存结果对于描述一个文档是不必要的，因为其是在印刷过程中计算的，每次印刷时都可以重新计算。
行内概念节点的实现 #一个行内概念节点只包含一段文本。但是如之前所说，作为一个特殊节点，其还有参数和抽象。注意一个概念节点不需要储存元参数，只需要储存其对应的一级概念名，而概念本身会确定元参数。另外，两级概念都有其参数列表，但是不需要一级概念的参数表，因为只需要二级概念的参数表就可以确定要一级概念的参数表。另外，二级概念的固定参数表也可以直接由二级概念本身确定，因此也不需要在节点中储存。
除此之外，每个概念节点还需要有一个全局唯一的编号，用来方便创建引用。
interface InlineNode{type: \u0026quot;inline\u0026quot;idx: number concept: stringparameters: ParameterListcacheResult: anychildren: [ Text ]abstrct: AbstractNode []}组概念节点的实现 #一个组概念除了元参数和子节点之外，还包含一个固有属性『连系』（relation），表示其和前一个节点的关系。连系只有两种取值：贴贴（chaining）和分离（separate）。
interface GroupNode{type: \u0026quot;group\u0026quot;idx: number concept: stringparameters: ParameterListcacheResult: anychildren: NonLeafNode []abstract: AbstractNode []relation: \u0026quot;chaining\u0026quot; | \u0026quot;separate\u0026quot;}其中NonLeafNode = ParagraphNode | ConceptNode，而ConceptNode = GroupNode | InlineNode | StructNode | SupportNode。
结构概念节点的实现 #一个结构概念表示一个横向展开的展示，比如表格的一行，或者分栏等。一个文档的横向结构不像纵向结构那样可以自由发展，因为页面的宽度是恒定的。因此，需要明确指定其包含多少列。
另外，结构也可以贴贴，因此也有连系参数。
interface StructNode{type: \u0026quot;structure\u0026quot; idx: number concept: stringparameters: ParameterListcacheResult: anychildren: NonLeafNode []abstract: AbstractNode []numChildren: numberrelation: \u0026quot;chaining\u0026quot; | \u0026quot;separate\u0026quot;}其中，children的长度等于numChildren的长度。
支撑概念节点的实现 #一个支撑概念通常是用来表示页面的导航、标注等的元素，不可编辑。
interface SupportNode{type: \u0026quot;support\u0026quot; idx: number concept: stringparameters: ParameterListcacheResult: anychildren: []abstract: AbstractNode []}抽象节点的实现 #之前说过，一个抽象节点是一个新的文档树的初始节点。
interface AbstractNode{type: \u0026quot;abstract\u0026quot;idx: number concept: stringparameters: ParameterListcacheResult: anychildren: NonLeafNode []abstract: AbstractNode []}印刷实现 #接下来描述如何将一棵节点树渲染成一个页面。这其中包含两个部分，第一是从抽象的层面，每个概念需要定义哪些东西，第二是具体如何实现（比如如何确定字体、如何确定宽度等）。这里先明确第一部分，之后再详细描述第二个部分。
渲染器在渲染节点时，会维护两个量，一个是当前环境（env），一个是节点的上下文（context）。环境和上下文都是一般的字典。
type Env = anytype Context = any渲染器会首先遍历整棵树若干次来建立context，然后再进行渲染。每次遍历都是深度优先的遍历，每次遍历时，节点需要检查环境和上下文，并进行一定的修改，然后返回是否完成，如果一次遍历中有节点未完成（比如需要后方节点的信息），那么就会进行第二次遍历，直到所有节点都完成或者达到次数上限为止。
在遍历时，每个节点需要定义两个函数，即进入时操作（enter）和离开时操作（exit）。
type PrinterEnterFunction = function enter(node: Node , env: Env , context: Context) =\u0026gt; [env: Env , context: Context]type PrinterExitFunction = function exit(node: Node , env: Env , context: Context) =\u0026gt; [env: Env , context: Context , cacheResult: any, finished: boolean]其中enter在进入节点时调用，exit在离开节点时调用。
所以，在所有遍历中，对于每个节点，会依次调用enter和exit函数若干次，每次调用中输出的context会作为下一个函数的context的输入，最后一个函数输出的context会作为渲染时的context。
在渲染阶段，需要每个节点提供一个React组件，这个组件接收之前遍历得到的context，并说明如何渲染。
type PrinterRenderFunction = function renderer({context: Contextnode: Nodechildren: React.ReactElement})因此，一个完整的渲染器应包括以上三个函数。
interface PrinterRenderer{enter: PrinterEnterFunctionexit: PrinterExitFunctionrenderer: PrinterRenderFunction}注意，虽然以上说明是对概念节点和抽象节点而言，但是对于段落节点，也提供一套完整的渲染器，而对于文本节点，要提供一个渲染函数（renderer）。
（一级）概念实现 #在说明了为了实现印刷，一个概念需要提供哪些东西后，就可以说明一个概念具体需要提供哪些东西了。如前所述，一个概念需要和一个概念类型对应、需要有一个全局唯一的名称以供索引、需要提供参数原型和元参数，并提供渲染的定义。
interface Concept{type: \u0026quot;group\u0026quot; | \u0026quot;inline\u0026quot; | \u0026quot;structure\u0026quot; | \u0026quot;support\u0026quot; | \u0026quot;abstract\u0026quot;name: stringmetaParameters: MetaParametersparameterPrototype: ParameterList}至于二级概念，实际上是对一级概念的重写，只需要指定一级概念的名称以及复写的参数列表就可以。
interface SecondConcept{firstConcept: stringname: stringdefaultOverride: ParameterListfixedOverride: FixedParameterList}`}),e.add({id:1,href:"/YText/docs/prologue/introduction/",title:"Introduction",description:`I believe articles are not barely texts, nor visual elements. Although our language is linear, words come one after another, we humen\u0026rsquo;s mind is far from linear, structures, branching, moods exist therein. Therefore I build YText, a text editor library that decouples the abstract structure and concrete visualization of an article.
YText is composed of three major components:
Editor, which allows one to edit the structure of an article without specifying how to render it.`,content:`I believe articles are not barely texts, nor visual elements. Although our language is linear, words come one after another, we humen\u0026rsquo;s mind is far from linear, structures, branching, moods exist therein. Therefore I build YText, a text editor library that decouples the abstract structure and concrete visualization of an article.
YText is composed of three major components:
Editor, which allows one to edit the structure of an article without specifying how to render it. Printer, which allows one to define how to render the abatract representation of an article (say into a web page). Concept System, which is shared by editor and printer, defining how to represent an article by the abstract representation. The so called \u0026ldquo;abstract representation\u0026rdquo; (terminology wise I call it intermediate representation, since the word \u0026ldquo;abstract\u0026rdquo; is used in another situation) of an article is organized as a tree (a json tree in implementation), whose nodes are concepts or trivial nodes.
About \u0026ldquo;Realization\u0026rdquo; #Sometimes I use the word \u0026ldquo;realization\u0026rdquo;, it is analogous to the term with the same name in OOP programing. In YText, some times an element provides a name and a group of parameter prototype, and another element specify a name and values of paramater, which is of the same type with the coresponding parameter prototype. In this case, I say the latter elements realizes the former element.
Notice that in YText, element names (or together with some other properties, like class), serves as the unique indicator of an element, which is like class name in OOP. The parameter prototype does not only defines how a parameter would be, but also serves as the default value of the parameters which can be used when coresponding term is not specified and can be overrided.
The Grammar of Intermediate Representation #As mentioned before, the intermediate representation in YText is a tree. Therefore two types of non-leaf nodes in this tree:
Concept nodes, and Paragraph nodes, and leaf nodes are all called text nodes. A text node is basically a string, which corresponding to a phrase in the article. A paragraph node is a list of text nodes and inline concept nodes (will explain later), which corresponding to a paragraph in the article.
Concept \u0026amp; Concept nodes #Each concept node belongs to a concept, which is specified by user, and it also provodes a group of parameters which realizes the concept. Each concept should specifies four properties:
The concept type, which is in {\u0026ldquo;group\u0026rdquo;, \u0026ldquo;structure\u0026rdquo;, \u0026ldquo;inline\u0026rdquo;, \u0026ldquo;support\u0026rdquo;, \u0026ldquo;abstract\u0026rdquo;}, which defines which kind of concept the concept is. The parameter prototype of this concept. The values of meta parameters. Meta -parameters are specified by YText. The values of inherent parameters. Inherent are specified by YText. The rendering method which takes concept parameter realization as input and defines how to render this concept into a visual element. Concept Types #Concept types are pre-defined in YText. There are five concept types: group, structure, inline, support and abstract. Each concept type defines specifies a group of parameter prototype, which is called the inherent parameters of this concept type. Each concept type also defines a local grammar, namely what type of nodes can its children be. The detailed definition of each type will be discussed later, but here I breifly explain each type, to give you a intuiation about each type.
A group node is a list of paragrahs, which is it self be seen as a whole. For examples a theorem in a mathmatics paper can be viewed as a group node. The \\item element in LateX can also be viewed as a group. Group nodes can form series, in which the group nodes comes one after the other (I call this chaining), for example the enumerate environment in LateX. A proof comes right after a theorem in a mathmatics paper is also an example of chaining group nodes. A structure node consists of several Group nodes. A structure node should be rendered in a a different direction of the ordinary direction of the document. If the document is rendered from top to bottom, then a structure node renders from left to right. One line in a table is an example. An inline node is of the same position of text nodes, but with styles. The \u0026lt;strong\u0026gt; tag in HTML is an example. A support node is a visual element that does not contain text contents (or more generally, can only contain an empty text node as its child). Support nodes are the non-text visual elements in an article. For example figures, images, table lines. It can even be non-visualable to printer and just serve as an aid to editor. An abstract node is simply the root node of a tree. The word \u0026ldquo;abstract\u0026rdquo; comes from a machanism in YText which allows an article fissions into several in the middle, which we will dicuss detailly later. Meta Parameters #YText specified meta parameter prototype, which should be realized by every concept node. There are three values to be specified:
force-block: If we force an element (mainly inline or support) to be rendered as a block in HTML. force-inline: If we force an element (mainly group, structure or support) to be rendered as an inline element in HTML. force-void: If we force an element to be uneditable (which is like support nodes). First Class Concepts and Second Class Concepts #As wise readers might have noticed, each concept node have two types of properties: those for defining intermediate trees and those for specifying how a node to rendered. Theoretically this might not be a problem, but technically, if a user of YText might not be the user of the editor: User A might use YText to develop a library, providing an implementation of the printer and editor, and provided it to user B who defines concepts and use them to write articles. Here problems occurs: when a library author leave users the freedom of defining their own concepts, they don\u0026rsquo;t mean to let users write js code to define how to render the concept nodes. Therefore, the rendering part and the structure defining part of a concept must be splitted. To this end, each concept in YText is composed of two parts, I call them first class concepts and second class concepts.
A first class concept, which should be provided by the library developer, specifies the concept type, a parameter prototype and the render function. A second class concept, which should be provided by the terminal user, specifies a first class concept and another parameter prototype and the rule to convert second class parameters into first class parameters.
Generally speaking, a first class concept should be universal enough which has several \u0026ldquo;slots\u0026rdquo; and agnostic to second class concepts. The second class concept fill in those slots by inidcating first class parameters.
Abstract #Each concept node has another property \u0026ldquo;abstract\u0026rdquo;, which is a list of abstract nodes (can be empty). As mentioned before, abstract nodes are roots of an intermediate tree. Therefore, the \u0026ldquo;abstract\u0026rdquo; property allows us to write a new article which ties at the current node.
The use of abstract can be quite flexible. For example, it can be used to write footnotes and sidenotes (the way of rendering it is up to our implementation). It can also be used to fold too long or not important contents, like the proof of a theorem in a mathmatics paper, a supplementary figure, or a comment that breaks the coherency wherever it is placed in the main text.
Notice that absract defines a new article, that has no difference with the original one, which means it can be as complecated, and the elements therein can also have abstracts. This mechanism allows a quite complex structure of an article, like a net. The structure of an article needs no longer to be linear. An article can be fissioned at the half and each goes to a complete article.
Implementation #To use YText, a user need to specify three components: the implementation of editor, the implementation of printer, and the definition of concepts. However, a user might not want to write an editor from their own. To this end, YText provides a default implementation of editor and printer, for those who don\u0026rsquo;t care about the implementation of editors and printers.
The decomposing of editor, printer and concepts also means every component can be used in a plugin manner. A user can use the editor of imeplementation A of YText, and use printer of imeplementation B of YText, and define their own concepts. They can even combine different imeplementations, like using just a small component of imeplementation A and other parts of imeplementation B.
`}),e.add({id:2,href:"/YText/docs/prologue/",title:"Prologue",description:"",content:""}),e.add({id:3,href:"/YText/docs/",title:"Docs",description:"",content:""}),e.add({id:4,href:"/YText/docs/notes-in-chinese/mouseless/",title:"Mouseless",description:`以下是我开发的时候写的一些笔记。没有写的很严谨，不完全符合现在的版本，仅供参考。
无鼠标操作 #YText编辑器提供了一系列功能来完成无鼠标操作，这些功能也可以被整合到用户自定义的编辑器中。
无鼠标操作功能分为三个核心部件：键盘事件管理器（KeyEventManager）和无鼠标元素（KeyEventElement）。
使用方法 #所有无鼠标项目分成了一系列小组，每个称为一系列无鼠标项目空间，用一个唯一的字符串标志。在初始时，每个项目会在监听器处注册自己所处的空间和在这个空间中的位置，其中位置也是一个字符串。 每个空间对应一个 ctrl + [X] 的按键组合，其中[X]是某个按键。在容器听到一个空间的按键组合按下后，会聚焦该空间中的一个合适的位置的元素，项目会向容器提供一个响应操作，如果在聚焦状态下按下enter键，则会调用该响应函数。如果松开ctrl + [X]键，则会调用元素的取消聚焦操作，但是会记录此时元素的位置，方便下次聚焦时快速启动。
如果在按下ctrl + [X]的按键组合的情况下按下方向键，则会切换空间中的位置（具体如何切换是用户定义的），此时会调用原先聚焦的元素的取消聚焦操作，并调用新聚焦元素的聚焦操作。
具体实现 #首先，键盘事件管理器代理slate的onKeyDown和onKeyUp函数，并使用React Context提供这两个方法。
type OnKeyDownFunction = (event)=\u0026gt;booleantype OnKeyUpFunction = (event)=\u0026gt;booleanvar KeyDownUpFunctionProxy = React.createContext\u0026lt;[OnKeyDownFunction | undefined,OnKeyUpFunction | undefined]\u0026gt;([undefined , undefined])键盘事件管理器的用户输入 #键盘事件管理器需要用户提供一系列成组的方法，每组方法包含:
interface EventManagerSpaceItem{// 空间名称（匹配用字符串）。spacename: string // 匹配用按键。key: string// 第一次聚焦时的位置。 activate_position: (position_list: string[], cur_position: string) =\u0026gt; number// 按下方向键时的聚焦切换。switch_position: (position_list: string[], cur_position: string, direction) =\u0026gt; number}键盘输入管理器还可以代理非无鼠标操作的操作（例如ctrl+s保存）。`,content:`以下是我开发的时候写的一些笔记。没有写的很严谨，不完全符合现在的版本，仅供参考。
无鼠标操作 #YText编辑器提供了一系列功能来完成无鼠标操作，这些功能也可以被整合到用户自定义的编辑器中。
无鼠标操作功能分为三个核心部件：键盘事件管理器（KeyEventManager）和无鼠标元素（KeyEventElement）。
使用方法 #所有无鼠标项目分成了一系列小组，每个称为一系列无鼠标项目空间，用一个唯一的字符串标志。在初始时，每个项目会在监听器处注册自己所处的空间和在这个空间中的位置，其中位置也是一个字符串。 每个空间对应一个 ctrl + [X] 的按键组合，其中[X]是某个按键。在容器听到一个空间的按键组合按下后，会聚焦该空间中的一个合适的位置的元素，项目会向容器提供一个响应操作，如果在聚焦状态下按下enter键，则会调用该响应函数。如果松开ctrl + [X]键，则会调用元素的取消聚焦操作，但是会记录此时元素的位置，方便下次聚焦时快速启动。
如果在按下ctrl + [X]的按键组合的情况下按下方向键，则会切换空间中的位置（具体如何切换是用户定义的），此时会调用原先聚焦的元素的取消聚焦操作，并调用新聚焦元素的聚焦操作。
具体实现 #首先，键盘事件管理器代理slate的onKeyDown和onKeyUp函数，并使用React Context提供这两个方法。
type OnKeyDownFunction = (event)=\u0026gt;booleantype OnKeyUpFunction = (event)=\u0026gt;booleanvar KeyDownUpFunctionProxy = React.createContext\u0026lt;[OnKeyDownFunction | undefined,OnKeyUpFunction | undefined]\u0026gt;([undefined , undefined])键盘事件管理器的用户输入 #键盘事件管理器需要用户提供一系列成组的方法，每组方法包含:
interface EventManagerSpaceItem{// 空间名称（匹配用字符串）。spacename: string // 匹配用按键。key: string// 第一次聚焦时的位置。 activate_position: (position_list: string[], cur_position: string) =\u0026gt; number// 按下方向键时的聚焦切换。switch_position: (position_list: string[], cur_position: string, direction) =\u0026gt; number}键盘输入管理器还可以代理非无鼠标操作的操作（例如ctrl+s保存）。
interface EventManagerNonSpaceItem{// 匹配用按键。key: string// 按下时操作。 on_activate: (event)=\u0026gt;boolean}键盘事件管理器和无鼠标元素的通信。 #键盘事件管理器必须在最上层，并通过Context向无鼠标元素传递注册自身的方法，无鼠标元素需要在键盘事件管理器中注册自身的位置以及三个函数：聚焦、响应、取消聚焦。
// 无鼠标元素激活操作。 type MouselessActivateOperation = ()=\u0026gt;void// 无鼠标元素取消激活操作。 type MouselessUnActivateOperation = ()=\u0026gt;void// 无鼠标元素响应操作。 type MouselessRun = ()=\u0026gt;void// 无鼠标元素注册函数。 type MouselessRegisterFunction = ( space: string, position: string, on_activate: MouselessActivateOperation, on_unactivate: MouselessUnActivateOperation, run: MouselessRun ) =\u0026gt; void// 提供无鼠标元素注册函数的上下文。 let MouselessRegister = React.createContext\u0026lt;MouselessRegisterFunction\u0026gt;(()=\u0026gt;{})`}),e.add({id:5,href:"/YText/docs/prologue/getstarted/",title:"Get Started",description:`In this page, we show the basic usage of YText by creating a simple example project.
Installation #Make sure you are in a React project and simply use npm to install YText:
npm install @ftyyy/ytextand can import ytext in your code:
import * from \u0026quot;@ftyyy/ytext\u0026quot;Use YText in your Project #In this section, we set up an example project to show how to use YText. There are three major steps: create concepts, create printer, and create editor.`,content:`In this page, we show the basic usage of YText by creating a simple example project.
Installation #Make sure you are in a React project and simply use npm to install YText:
npm install @ftyyy/ytextand can import ytext in your code:
import * from \u0026quot;@ftyyy/ytext\u0026quot;Use YText in your Project #In this section, we set up an example project to show how to use YText. There are three major steps: create concepts, create printer, and create editor.
Create Concepts #First import necessary classes from YText:
import {FirstClassConcept , SecondClassConcept , } from \u0026quot;@ftyyy/ytext\u0026quot;Then create a first class concept, say we want to write a mathmatics paper, hence we create a concept for propositions:
let math = new FirstClassConcept({type:\u0026quot;group\u0026quot; , name: \u0026quot;math\u0026quot; , parameter_prototype: {name: {val: \u0026quot;Proposition\u0026quot;, type: \u0026quot;string\u0026quot; , } , }})As we know, there are different types of propositions in a mathmatics paper (e.g. Theorems, Lemmas, Corollaries). We create a second class concept that inherits the first class concept we just created and override its parameters:
let theorem = new SecondClassConcept({type: \u0026quot;group\u0026quot; , first_concept: \u0026quot;math\u0026quot; , // each first class concept is referred by its type and name.name: \u0026quot;theorem\u0026quot; , default_override: { // parameters that allow users to determine.alias: {val: \u0026quot;\u0026quot; , type: \u0026quot;string\u0026quot; , } , } , fixed_override: { // assigning values to the first class concept parameters.name: { val: \u0026quot;p =\u0026gt; p.alias.val ? \`Theorem (\${p.alias.val})\` : 'Theorem'\u0026quot; , // this type allow dynamic value that depends on the parameters of the second class concepttype: \u0026quot;function\u0026quot; , }}})(Actually, this is not the best way to define a theorem concept. Here I just want to display the usage of function-type parameters.)
Creating Printer #Next, we need to define how to transfer a first class concept node into a visual element (A node in React). YText provides abundant tools to develop your own printer. First we need to import the tools that we will use:
import {PreprocessInformation , GroupNode , OrderContexter , get_default_group_renderer , DefaultAbstractRendererAsProperty , PrinterStructureBoxText , PrinterPartBox , } from \u0026quot;@ftyyy/ytext\u0026quot;When rendering nodes, YText use so called context to let each node know its position in the article and its relationship with others. The detailed machanisms will be introduced later. YText have numerous tools to help build context. They are called contexters. Here we will use OrderContexter, that allows a node to know its number in the article (for example we might want to start a theorem with: \u0026ldquo;Thm 1: xxx\u0026rdquo;, obviously we don\u0026rsquo;t want to number it manually). We can first create a OrderContexter:
let number_gene = (info:PreprocessInformation\u0026lt;GroupNode\u0026gt;)=\u0026gt;new OrderContexter\u0026lt;GroupNode\u0026gt;(\u0026quot;math\u0026quot;)Notice that contexters are stateless, so we always create them by functions. Next, we can create a printer. We can use tools that offered by YText. For example PrinterStructureBoxText provides a special style for title texts, and PrinterPartBox provides a margin style for group nodes.
let math_printer = get_default_group_renderer({// contexters that will be used to creat context.contexters: [ number_gene, ] , // the element to start with.pre_element: (info: PreprocessInformation\u0026lt;GroupNode\u0026gt;) =\u0026gt; {let {node , context , parameters , env} = infolet number = number_gene(info).get_context(context) // generate number.let name = parameters.name // get name from parameters.return \u0026lt;PrinterStructureBoxText inline\u0026gt;{\`\${name} (\${number})\`}\u0026lt;/PrinterStructureBoxText\u0026gt;} , // the box that contains the nodeouter: (props) =\u0026gt; {return \u0026lt;PrinterPartBox subtitle_like\u0026gt;{props.children}\u0026lt;/PrinterPartBox\u0026gt;} , })We will also need to create default renderers for all the node types. YText also provides tools to simplify that:
import {get_default_paragraph_renderer , useless_renderer_block , useless_renderer_inline , useless_renderer_text , } from \u0026quot;@ftyyy/ytext\u0026quot;let default_renderers = {\u0026quot;group\u0026quot; : useless_renderer_block , \u0026quot;structure\u0026quot; : useless_renderer_block , \u0026quot;support\u0026quot; : useless_renderer_block , \u0026quot;abstract\u0026quot; : useless_renderer_block , \u0026quot;paragraph\u0026quot; : get_default_paragraph_renderer({}) , \u0026quot;inline\u0026quot; : useless_renderer_inline , \u0026quot;text\u0026quot; : useless_renderer_text , }When YText see a undefined concept, the default printers will be in use.
Creating Editor #Next, let\u0026rsquo;s create editors. We can directly use the default editor implementation provide by YText.
import {get_deafult_group_editor_with_appbar , get_default_editors , } from \u0026quot;@ftyyy/ytext\u0026quot;let math_editor = get_deafult_group_editor_with_appbar({get_label: (node,parameters) =\u0026gt; parameters.name})Combining Everything Together #Now we have almost done. Let\u0026rsquo;s write a full component with concepts, printers and editors we just defined.
import {Printer , EditorCore , AbstractNode , PrinterCache , DefaultPrinterComponent , DefaultEditorComponent , } from \u0026quot;@ftyyy/ytext\u0026quot;class App extends React.Component\u0026lt;{} , {tree: AbstractNode}\u0026gt;{editor_ref : React.RefObject\u0026lt;DefaultEditorComponent\u0026gt; // reference to editor component.printer: Printereditorcore: EditorCoreconstructor(props: any){super(props)let me = this// build printer.this.printer = new Printer([math] , // feed in first class concepts.[theorem] , // feed in second class concepts.{ // feed in all renderers.group: {\u0026quot;math\u0026quot;: math_printer , } , structure: {} , inline: {} , support: {} , abstract: {} , } , default_renderers , // feed in all default renderers.)// build editor core.this.editorcore = new EditorCore({renderers: { // put in renderers.group: {math: math_editor , } , structure: {} , inline: {} , support: {} , abstract: {} , } , default_renderers: get_default_editors(), // feed in default renderers.printer: me.printer , // feed in the printer.})// initialize the inermediate tree.this.state = {tree: this.editorcore.create_abstract(\u0026quot;root\u0026quot;)}this.editor_ref = React.createRef()}render(){let me = thisreturn \u0026lt;div\u0026gt;\u0026lt;div style = {{position: \u0026quot;absolute\u0026quot;, width: \u0026quot;48%\u0026quot;, left: \u0026quot;1%\u0026quot;, top: \u0026quot;1%\u0026quot;, height: \u0026quot;98%\u0026quot;}}\u0026gt;\u0026lt;DefaultEditorComponent // editor component.ref = {me.editor_ref}editorcore = {me.editorcore} // input editor core.// This is the initialization of editor, the updates in the tree will not trigger rerendering.init_rootchildren = {me.state.tree.children} onSave = {()=\u0026gt;{ // the callback function whem ctrl+S is pressed.me.setState({tree: me.editor_ref.current.get_root() as AbstractNode})// save the tree to backend.// save(me.state.tree)}}/\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div style = {{position: \u0026quot;absolute\u0026quot;, width: \u0026quot;48%\u0026quot;, left: \u0026quot;51%\u0026quot;, top: \u0026quot;1%\u0026quot;, height: \u0026quot;98%\u0026quot;,}} \u0026gt;\u0026lt;DefaultPrinterComponent // printer component.printer = {me.printer} // input printer core.root = {me.state.tree} // the update of state.tree will trigger rerenderring of Printer.\u0026gt;\u0026lt;/DefaultPrinterComponent\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;}}It will result in a React component like this: The left part is the editing area, where we can write texts and add theorems. When pressing ctrl+s, the printer (on the right) will be updated: `}),e.add({id:6,href:"/YText/docs/advanced/",title:"Advanced Tutorials",description:"",content:""}),e.add({id:7,href:"/YText/docs/notes-in-chinese/",title:"Notes in Chinese",description:"",content:""}),e.add({id:8,href:"/YText/docs/advanced/advanced/",title:"Advanced",description:"I will write this part later.",content:`I will write this part later.
`}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()