<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes in Chinese on </title>
    <link>https://fftyyy.github.io/YText/docs/notes-in-chinese/</link>
    <description>Recent content in Notes in Chinese on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Feb 2023 23:31:53 -0500</lastBuildDate><atom:link href="https://fftyyy.github.io/YText/docs/notes-in-chinese/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://fftyyy.github.io/YText/docs/notes-in-chinese/intro/</link>
      <pubDate>Sun, 05 Feb 2023 23:31:53 -0500</pubDate>
      
      <guid>https://fftyyy.github.io/YText/docs/notes-in-chinese/intro/</guid>
      <description>以下是我开发的时候写的一些笔记。没有写的很严谨，不完全符合现在的版本，仅供参考。
YText是一个文档编辑库，其核心包括两个部分：
编辑器（Editor）：将用所见即所得的方式来编辑文档的中间表示； 印刷器（Printer）：将文档的中间表示渲染成网页。 其中，『文档的中间表示（ intermediate-representation ）』是YText表示文档的真正方式。其将文档组织成树，只保留语义信息，不包含样式或者排版信息。
中间表示的语法 #一个文档的中间表示将文档组织成树，树上的非叶子节点有两种类型：
段落节点（paragraph）； 概念节点（concept）， 而叶节点一定是文本节点（text）。其中，概念节点有四种类型：
组（Group）； 结构（Structure）； 支撑（Support）； 行内（Inline）， 另外，节点本身可以包含若干新的树作为其属性（不是子树），这一类树的根节点本质上也是组，但是为了区分，称其为抽象（Abstract）节点。
一棵树的根节点一定是抽象节点，叶节点一定是文本节点。
任何一个概念节点有三种参数：
参数（Parameters）：由概念定义，且在编辑过程中可以更改的参数； 元参数（meta-parameters）：由概念定义，且在编辑过程中不可更改的参数； 固有参数（inherent-parameters）：由概念类型定义，且在编辑过程中可以更改的参数。 概念 #在YText中，有一种被称为『概念』的概念。大体上来说，概念对应于文档中的可辨认的一个部分（例如定理）。 一个概念的定义要包含以下几个部分：
对应的特殊节点类型，以及对应的元参数（meta-parameters）取值； 参数（parameters）列表原型，包括参数的默认值； 这个节点的渲染方式， 可见，从概念开始，就需要定义如何渲染的问题了。
一级概念和二级概念 #一级概念（first-concept）和二级概念（second-concept）是为了向实践妥协而区分出的概念。大体来说，我们一方面希望概念由文档自身定义，另一方面因为概念包含渲染等问题，我们不可能在文档里包含一段js程序用于描述渲染（更不用提定义如何渲染本身就是一个大工程），因此我们对概念分级。大体来说，一级概念是在安装时确定的，其所有实现都是在代码里硬编码的。而二级概念则将一个一级概念作为其属性，并定义如何重写（override）一级概念的参数列表。重写有两种方式：
固定（Fix）：固定某个原先参数的值，使之不可改变； 改变默认值（Change-Default）：改变某个原先参数的默认值，注意这一步中可以新增参数； 中间表示实现 #接下来简述中间表示的具体实现。中间表示表示成一个json树。其中每个叶节点一定是一个文本节点。
interface TextNode {text: string}表示一段文本。
而一个段落节点只能包含文本（text）节点和行内（inline）节点。
interface ParagraphNode {type: &amp;quot;paragraph&amp;quot;children: (Text | Inline) []}对于概念，之前说过，其需要有固有参数和元参数，元参数包括三个值：
是否强制这个节点为行内（Inline）节点； 是否强制这个节点为空（Void）节点； 是否强制这个节点为块级（Block）节点： interface MetaParameters{forceInline?: boolean,forceBlock?: boolean,forceVoid?: boolean,}注意，元参数通常是用来对支撑节点进行补充说明的，因为支撑节点本身并不明确应该作为块级、行内还是空元素。其他特殊类型的节点，其类型本身给予了此类清晰，例如行内节点应该作为行内元素，组节点应该作为块级元素。但是对于其他特殊类型，也保留确定元参数的自由。</description>
    </item>
    
    <item>
      <title>Mouseless</title>
      <link>https://fftyyy.github.io/YText/docs/notes-in-chinese/mouseless/</link>
      <pubDate>Sun, 05 Feb 2023 23:35:04 -0500</pubDate>
      
      <guid>https://fftyyy.github.io/YText/docs/notes-in-chinese/mouseless/</guid>
      <description>以下是我开发的时候写的一些笔记。没有写的很严谨，不完全符合现在的版本，仅供参考。
无鼠标操作 #YText编辑器提供了一系列功能来完成无鼠标操作，这些功能也可以被整合到用户自定义的编辑器中。
无鼠标操作功能分为三个核心部件：键盘事件管理器（KeyEventManager）和无鼠标元素（KeyEventElement）。
使用方法 #所有无鼠标项目分成了一系列小组，每个称为一系列无鼠标项目空间，用一个唯一的字符串标志。在初始时，每个项目会在监听器处注册自己所处的空间和在这个空间中的位置，其中位置也是一个字符串。 每个空间对应一个 ctrl + [X] 的按键组合，其中[X]是某个按键。在容器听到一个空间的按键组合按下后，会聚焦该空间中的一个合适的位置的元素，项目会向容器提供一个响应操作，如果在聚焦状态下按下enter键，则会调用该响应函数。如果松开ctrl + [X]键，则会调用元素的取消聚焦操作，但是会记录此时元素的位置，方便下次聚焦时快速启动。
如果在按下ctrl + [X]的按键组合的情况下按下方向键，则会切换空间中的位置（具体如何切换是用户定义的），此时会调用原先聚焦的元素的取消聚焦操作，并调用新聚焦元素的聚焦操作。
具体实现 #首先，键盘事件管理器代理slate的onKeyDown和onKeyUp函数，并使用React Context提供这两个方法。
type OnKeyDownFunction = (event)=&amp;gt;booleantype OnKeyUpFunction = (event)=&amp;gt;booleanvar KeyDownUpFunctionProxy = React.createContext&amp;lt;[OnKeyDownFunction | undefined,OnKeyUpFunction | undefined]&amp;gt;([undefined , undefined])键盘事件管理器的用户输入 #键盘事件管理器需要用户提供一系列成组的方法，每组方法包含:
interface EventManagerSpaceItem{// 空间名称（匹配用字符串）。spacename: string // 匹配用按键。key: string// 第一次聚焦时的位置。 activate_position: (position_list: string[], cur_position: string) =&amp;gt; number// 按下方向键时的聚焦切换。switch_position: (position_list: string[], cur_position: string, direction) =&amp;gt; number}键盘输入管理器还可以代理非无鼠标操作的操作（例如ctrl+s保存）。</description>
    </item>
    
  </channel>
</rss>
